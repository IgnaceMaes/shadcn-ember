{
  "$schema": "https://shadcn-ember.com/schema/registry-item.json",
  "name": "slider",
  "type": "registry:ui",
  "files": [
    {
      "path": "registry/new-york-v4/ui/slider.gts",
      "content": "import { fn } from '@ember/helper';\nimport { on } from '@ember/modifier';\nimport { htmlSafe } from '@ember/template';\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nimport { cn } from '@/lib/utils';\n\nimport type Owner from '@ember/owner';\n\ninterface SliderSignature {\n  Element: HTMLDivElement;\n  Args: {\n    value?: number[];\n    defaultValue?: number[];\n    onValueChange?: (value: number[]) => void;\n    min?: number;\n    max?: number;\n    step?: number;\n    disabled?: boolean;\n    orientation?: 'horizontal' | 'vertical';\n    class?: string;\n  };\n}\n\nclass Slider extends Component<SliderSignature> {\n  @tracked internalValue: number[];\n\n  constructor(owner: Owner, args: SliderSignature['Args']) {\n    super(owner, args);\n    this.internalValue = args.value ?? args.defaultValue ?? [0];\n  }\n\n  get value() {\n    return this.args.value ?? this.internalValue;\n  }\n\n  get min() {\n    return this.args.min ?? 0;\n  }\n\n  get max() {\n    return this.args.max ?? 100;\n  }\n\n  get step() {\n    return this.args.step ?? 1;\n  }\n\n  get orientation() {\n    return this.args.orientation ?? 'horizontal';\n  }\n\n  get values() {\n    const val = this.value;\n    const def = this.args.defaultValue;\n    return Array.isArray(val) ? val : Array.isArray(def) ? def : [this.min];\n  }\n\n  get rangePercentage() {\n    if (this.values.length === 0) return { start: 0, width: 0 };\n\n    // For single value sliders, show progress from min to value\n    if (this.values.length === 1) {\n      const value = this.values[0];\n      if (value === undefined) return { start: 0, width: 0 };\n      const start = 0;\n      const end = ((value - this.min) / (this.max - this.min)) * 100;\n      return { start, width: end };\n    }\n\n    // For range sliders, show progress between the two values\n    const minVal = Math.min(...this.values);\n    const maxVal = Math.max(...this.values);\n    const start = ((minVal - this.min) / (this.max - this.min)) * 100;\n    const end = ((maxVal - this.min) / (this.max - this.min)) * 100;\n    return { start, width: end - start };\n  }\n\n  get rangeStyle() {\n    const { start, width } = this.rangePercentage;\n    if (this.orientation === 'vertical') {\n      return htmlSafe(`bottom: ${start}%; height: ${width}%`);\n    }\n    return htmlSafe(`left: ${start}%; width: ${width}%`);\n  }\n\n  thumbStyle = (index: number) => {\n    const val = this.values[index] ?? 0;\n    const percentage = ((val - this.min) / (this.max - this.min)) * 100;\n    if (this.orientation === 'vertical') {\n      return htmlSafe(`bottom: ${percentage}%; transform: translateY(50%)`);\n    }\n    return htmlSafe(`left: ${percentage}%; transform: translateX(-50%)`);\n  };\n\n  handleInput = (index: number, event: Event) => {\n    const target = event.target as HTMLInputElement;\n    const newValue = [...this.values];\n    newValue[index] = parseFloat(target.value);\n    this.internalValue = newValue;\n    this.args.onValueChange?.(newValue);\n  };\n\n  handleThumbPointerDown = (index: number, event: PointerEvent) => {\n    if (this.args.disabled) return;\n\n    event.preventDefault();\n    const slider = (event.currentTarget as HTMLElement).parentElement;\n    if (!slider) return;\n\n    // Capture the pointer to receive all pointer events\n    (event.currentTarget as HTMLElement).setPointerCapture(event.pointerId);\n\n    const updateValue = (clientPos: number) => {\n      const rect = slider.getBoundingClientRect();\n      let percentage: number;\n\n      if (this.orientation === 'vertical') {\n        percentage = 1 - (clientPos - rect.top) / rect.height;\n      } else {\n        percentage = (clientPos - rect.left) / rect.width;\n      }\n\n      percentage = Math.max(0, Math.min(1, percentage));\n      const rawValue = this.min + percentage * (this.max - this.min);\n      const steppedValue = Math.round(rawValue / this.step) * this.step;\n      const clampedValue = Math.max(this.min, Math.min(this.max, steppedValue));\n\n      const newValue = [...this.values];\n      newValue[index] = clampedValue;\n      this.internalValue = newValue;\n      this.args.onValueChange?.(newValue);\n    };\n\n    const handlePointerMove = (e: PointerEvent) => {\n      updateValue(this.orientation === 'vertical' ? e.clientY : e.clientX);\n    };\n\n    const handlePointerUp = () => {\n      document.removeEventListener('pointermove', handlePointerMove);\n      document.removeEventListener('pointerup', handlePointerUp);\n    };\n\n    document.addEventListener('pointermove', handlePointerMove);\n    document.addEventListener('pointerup', handlePointerUp);\n  };\n\n  handleTrackClick = (event: PointerEvent) => {\n    if (this.args.disabled) return;\n\n    event.preventDefault();\n    const target = event.currentTarget as HTMLElement;\n\n    // Calculate initial value and find closest thumb\n    const rect = target.getBoundingClientRect();\n    let percentage: number;\n\n    if (this.orientation === 'vertical') {\n      percentage = 1 - (event.clientY - rect.top) / rect.height;\n    } else {\n      percentage = (event.clientX - rect.left) / rect.width;\n    }\n\n    percentage = Math.max(0, Math.min(1, percentage));\n    const rawValue = this.min + percentage * (this.max - this.min);\n    const steppedValue = Math.round(rawValue / this.step) * this.step;\n    const clampedValue = Math.max(this.min, Math.min(this.max, steppedValue));\n\n    // Find closest thumb\n    let closestIndex = 0;\n    let closestDistance = Math.abs((this.values[0] ?? 0) - clampedValue);\n\n    for (let i = 1; i < this.values.length; i++) {\n      const distance = Math.abs((this.values[i] ?? 0) - clampedValue);\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestIndex = i;\n      }\n    }\n\n    // Set initial value\n    const newValue = [...this.values];\n    newValue[closestIndex] = clampedValue;\n    this.internalValue = newValue;\n    this.args.onValueChange?.(newValue);\n\n    // Start drag operation\n    (event.currentTarget as HTMLElement).setPointerCapture(event.pointerId);\n\n    const updateValue = (clientPos: number) => {\n      const rect = target.getBoundingClientRect();\n      let percentage: number;\n\n      if (this.orientation === 'vertical') {\n        percentage = 1 - (clientPos - rect.top) / rect.height;\n      } else {\n        percentage = (clientPos - rect.left) / rect.width;\n      }\n\n      percentage = Math.max(0, Math.min(1, percentage));\n      const rawValue = this.min + percentage * (this.max - this.min);\n      const steppedValue = Math.round(rawValue / this.step) * this.step;\n      const clampedValue = Math.max(this.min, Math.min(this.max, steppedValue));\n\n      const newValue = [...this.values];\n      newValue[closestIndex] = clampedValue;\n      this.internalValue = newValue;\n      this.args.onValueChange?.(newValue);\n    };\n\n    const handlePointerMove = (e: PointerEvent) => {\n      updateValue(this.orientation === 'vertical' ? e.clientY : e.clientX);\n    };\n\n    const handlePointerUp = () => {\n      document.removeEventListener('pointermove', handlePointerMove);\n      document.removeEventListener('pointerup', handlePointerUp);\n    };\n\n    document.addEventListener('pointermove', handlePointerMove);\n    document.addEventListener('pointerup', handlePointerUp);\n  };\n\n  <template>\n    <div\n      class={{cn\n        \"relative flex w-full touch-none items-center select-none data-disabled:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col\"\n        @class\n      }}\n      data-disabled={{if @disabled \"true\"}}\n      data-orientation={{this.orientation}}\n      data-slot=\"slider\"\n      ...attributes\n    >\n      {{! template-lint-disable no-invalid-interactive no-pointer-down-event-binding }}\n      <div\n        class=\"bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5\"\n        data-orientation={{this.orientation}}\n        data-slot=\"slider-track\"\n        {{on \"pointerdown\" this.handleTrackClick}}\n      >\n        <div\n          class=\"bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full\"\n          data-orientation={{this.orientation}}\n          data-slot=\"slider-range\"\n          style={{this.rangeStyle}}\n        ></div>\n      </div>\n      {{#each this.values as |val index|}}\n        {{! template-lint-disable no-pointer-down-event-binding }}\n        <div\n          class=\"border-primary ring-ring/50 absolute block size-4 shrink-0 rounded-full border bg-white shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50 cursor-pointer\"\n          data-slot=\"slider-thumb\"\n          style={{this.thumbStyle index}}\n          tabindex={{if @disabled \"-1\" \"0\"}}\n          {{on \"pointerdown\" (fn this.handleThumbPointerDown index)}}\n        ></div>\n      {{/each}}\n    </div>\n  </template>\n}\n\nexport { Slider };\n",
      "type": "registry:ui"
    }
  ]
}
